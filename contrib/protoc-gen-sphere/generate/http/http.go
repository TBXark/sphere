package http

import (
	"fmt"
	"net/http"
	"os"
	"slices"
	"strings"

	validatepb "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	"github.com/TBXark/sphere/contrib/protoc-gen-sphere/generate/goindent"
	"github.com/TBXark/sphere/contrib/protoc-gen-sphere/generate/parser"
	"github.com/TBXark/sphere/contrib/protoc-gen-sphere/generate/swagger"
	"github.com/TBXark/sphere/contrib/protoc-gen-sphere/generate/template"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	deprecationComment = "// Deprecated: Do not use."
)

const (
	ctxPackage      = protogen.GoImportPath("context")
	validatePackage = protogen.GoImportPath("github.com/bufbuild/protovalidate-go")
)

var methodSets = make(map[string]int)

func GenerateFile(gen *protogen.Plugin, file *protogen.File, conf *Config) *protogen.GeneratedFile {
	if len(file.Services) == 0 || (conf.Omitempty && !hasHTTPRule(file.Services)) {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_sphere.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateFileHeader(gen, file, g)
	generateFileContent(gen, file, g, conf)
	return g
}

func generateFileHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-sphere. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, conf *Config) {
	if len(file.Services) == 0 {
		return
	}
	g.P("var _ = new(", ctxPackage.Ident("Context"), ")")
	genConf := NewGenConf(g, conf)
	generateGoImport(file, g, conf, genConf)
	g.P()
	for _, service := range file.Services {
		generateService(gen, file, g, service, genConf)
	}
}

func generateGoImport(file *protogen.File, g *protogen.GeneratedFile, conf *Config, genConf *GenConfig) {
	idents := []*goindent.GoIdent{
		conf.RouterType,
		conf.ContextType,
		conf.ErrorRespType,
		conf.DataRespType,
		conf.ServerHandlerFunc,
		conf.ParseJsonFunc,
		conf.ParseUriFunc,
		conf.ParseFormFunc,
	}
	genericGen := func(i int) string {
		if i == 0 {
			return ""
		}
		var sb strings.Builder
		sb.WriteString("[")
		for j := 0; j < i; j++ {
			if j > 0 {
				sb.WriteString(",")
			}
			sb.WriteString("string")
		}
		sb.WriteString("]")
		return sb.String()
	}
	imported := make(map[string]struct{}, len(idents))
	for _, i := range idents {
		_, exist := imported[string(i.Path)]
		if !exist {
			if i.IsFunc {
				g.P("var _ = ", i.GoIdent())
			} else {
				g.P("var _ = new(", i.GoIdent(), genericGen(i.GenericCount), ")")
			}
			imported[string(i.Path)] = struct{}{}
		}
	}
LOOP:
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if slices.ContainsFunc(method.Input.Fields, hasValidateOptions) {
				g.P("var _ = new(", validatePackage.Ident("Validator"), ")")
				genConf.packageDesc.ValidateFunc = g.QualifiedGoIdent(validatePackage.Ident("Validate"))
				break LOOP
			}
		}
	}
}

func generateService(_ *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, conf *GenConfig) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	sd := &template.ServiceDesc{
		ServiceType: service.GoName,
		ServiceName: string(service.Desc.FullName()),
		Metadata:    file.Desc.Path(),
		Package:     conf.packageDesc,
	}
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
		if rule != nil && ok {
			for _, bind := range rule.AdditionalBindings {
				sd.Methods = append(sd.Methods, buildHTTPRule(g, service, method, bind, conf))
			}
			sd.Methods = append(sd.Methods, buildHTTPRule(g, service, method, rule, conf))
		} else if !conf.omitempty {
			// Method with no http_rule defined, automatically generating a default POST method.
			path := fmt.Sprintf("%s/%s/%s", conf.omitemptyPrefix, service.Desc.FullName(), method.Desc.Name())
			sd.Methods = append(sd.Methods, buildMethodDesc(g, method, http.MethodPost, path, conf))
		}
	}
	if len(sd.Methods) != 0 {
		g.P(sd.Execute())
	}
}

func hasHTTPRule(services []*protogen.Service) bool {
	for _, service := range services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
			if rule != nil && ok {
				return true
			}
		}
	}
	return false
}

func hasValidateOptions(field *protogen.Field) bool {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	return proto.HasExtension(opts, validatepb.E_Field)
}

func buildHTTPRule(g *protogen.GeneratedFile, service *protogen.Service, m *protogen.Method, rule *annotations.HttpRule, conf *GenConfig) *template.MethodDesc {
	var (
		path         string
		method       string
		body         string
		responseBody string
	)
	path, method = parser.HttpRule(rule, path, method)
	if path == "" {
		path = fmt.Sprintf("%s/%s/%s", conf.omitemptyPrefix, service.Desc.FullName(), m.Desc.Name())
	}
	body = rule.Body
	responseBody = rule.ResponseBody
	md := buildMethodDesc(g, m, method, path, conf)
	if method == http.MethodGet || method == http.MethodDelete {
		if body != "" {
			_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: %s %s body should not be declared.\n", method, path)
		}
	} else {
		if body == "" {
			_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: %s %s does not declare a body.\n", method, path)
		}
	}
	if body == "*" {
		md.HasBody = true
		md.Body = ""
	} else if body != "" {
		md.HasBody = true
		md.Body = "." + camelCaseVars(body)
	} else {
		md.HasBody = false
	}
	if responseBody == "*" {
		md.ResponseBody = ""
	} else if responseBody != "" {
		md.ResponseBody = "." + camelCaseVars(responseBody)
	}
	return md
}

func buildMethodDesc(g *protogen.GeneratedFile, m *protogen.Method, method, path string, conf *GenConfig) *template.MethodDesc {
	ginRoute, err := parser.GinRoute(path)
	if err != nil {
		return nil
	}
	defer func() { methodSets[m.GoName]++ }()
	swagRoute := swagger.ConvertGinToSwaggerPath(ginRoute)
	vars := parser.GinRouteParams(ginRoute)
	forms := parser.QueryValue(m, method, vars)
	comment := swagger.MethodCommend(m)
	anno := swagger.Config{
		Method:        method,
		Path:          swagRoute,
		PathVars:      vars,
		QueryVars:     forms,
		Auth:          conf.swaggerAuth,
		DataResponse:  conf.packageDesc.DataResponseType,
		ErrorResponse: conf.packageDesc.ErrorResponseType,
	}
	return &template.MethodDesc{
		Name:         m.GoName,
		OriginalName: string(m.Desc.Name()),
		Num:          methodSets[m.GoName],
		Request:      g.QualifiedGoIdent(m.Input.GoIdent),
		Reply:        g.QualifiedGoIdent(m.Output.GoIdent),
		Comment:      comment,
		Path:         path,
		Method:       method,
		HasVars:      len(vars) > 0,
		HasQuery:     len(forms) > 0,
		GinPath:      ginRoute,
		Swagger:      swagger.BuildAnnotations(m, &anno),
		NeedValidate: slices.ContainsFunc(m.Input.Fields, hasValidateOptions),
	}
}
