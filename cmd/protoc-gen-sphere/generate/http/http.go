package http

import (
	"fmt"
	"net/http"
	"slices"

	validatepb "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	"github.com/TBXark/sphere/cmd/protoc-gen-sphere/generate/log"
	"github.com/TBXark/sphere/cmd/protoc-gen-sphere/generate/parser"
	"github.com/TBXark/sphere/cmd/protoc-gen-sphere/generate/template"
	"github.com/TBXark/sphere/cmd/protoc-gen-sphere/generate/utils"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	deprecationComment = "// Deprecated: Do not use."
)

const (
	ctxPackage      = protogen.GoImportPath("context")
	validatePackage = protogen.GoImportPath("buf.build/go/protovalidate")
)

var methodSets = make(map[string]int)

func GenerateFile(gen *protogen.Plugin, file *protogen.File, conf *Config) *protogen.GeneratedFile {
	if len(file.Services) == 0 || (conf.Omitempty && !hasHTTPRule(file.Services)) {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_sphere.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateFileHeader(gen, file, g)
	generateFileContent(gen, file, g, conf)
	return g
}

func generateFileHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-sphere. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc             ", utils.ProtocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, conf *Config) {
	if len(file.Services) == 0 {
		return
	}
	g.P("var _ = new(", ctxPackage.Ident("Context"), ")")
	genConf := NewGenConf(g, conf)
	generateGoImport(file, g, conf, genConf)
	g.P()
	for _, service := range file.Services {
		generateService(gen, file, g, service, genConf)
	}
}

func generateGoImport(file *protogen.File, g *protogen.GeneratedFile, conf *Config, genConf *GenConfig) {
	didImport := make(map[protogen.GoImportPath]bool)
	for _, ident := range []protogen.GoIdent{conf.RouterType, conf.ContextType, conf.ErrorRespType} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = new(", ident, ")")
		}
	}
	for _, ident := range []protogen.GoIdent{conf.ParseFormFunc, conf.ParseUriFunc, conf.ParseJsonFunc} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = ", ident)
		}
	}
	for _, ident := range []protogen.GoIdent{conf.DataRespType} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = new(", ident, "[int])")
		}
	}
	for _, ident := range []protogen.GoIdent{conf.ServerHandlerFunc} {
		if !didImport[ident.GoImportPath] {
			didImport[ident.GoImportPath] = true
			g.P("var _ = ", ident, "[int]")
		}
	}
LOOP:
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if hasValidateOptionsInMessage(method.Input) || slices.ContainsFunc(method.Input.Fields, hasValidateOptions) {
				g.P("var _ = new(", validatePackage.Ident("Validator"), ")")
				genConf.packageDesc.ValidateFunc = g.QualifiedGoIdent(validatePackage.Ident("Validate"))
				break LOOP
			}
		}
	}
}

func generateService(_ *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, conf *GenConfig) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	sd := &template.ServiceDesc{
		ServiceType: service.GoName,
		ServiceName: string(service.Desc.FullName()),
		Metadata:    file.Desc.Path(),
		Package:     conf.packageDesc,
	}
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			log.Warn("Method `%s.%s` is streaming, it will be ignored. File: `%s`",
				method.Parent.Desc.Name(),
				method.Desc.Name(),
				method.Parent.Location.SourceFile,
			)
			continue
		}
		rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
		if rule != nil && ok {
			for _, bind := range rule.AdditionalBindings {
				if desc, err := buildHTTPRule(g, service, method, bind, conf); err == nil {
					sd.Methods = append(sd.Methods, desc)
				}
			}
			if desc, err := buildHTTPRule(g, service, method, rule, conf); err == nil {
				sd.Methods = append(sd.Methods, desc)
			}
		} else if !conf.omitempty {
			// Method with no http_rule defined, automatically generating a default POST method.
			path := fmt.Sprintf("%s/%s/%s", conf.omitemptyPrefix, service.Desc.FullName(), method.Desc.Name())
			res := &parser.HttpRule{
				Path:         path,
				Method:       http.MethodPost,
				HasBody:      true,
				Body:         "*",
				ResponseBody: "",
			}
			if desc, err := buildMethodDesc(g, method, res, conf); err == nil {
				sd.Methods = append(sd.Methods, desc)
			}
		}
	}
	if len(sd.Methods) != 0 {
		g.P(sd.Execute())
	}
}

func hasHTTPRule(services []*protogen.Service) bool {
	for _, service := range services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
			if rule != nil && ok {
				return true
			}
		}
	}
	return false
}

func hasValidateOptions(field *protogen.Field) bool {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	return proto.HasExtension(opts, validatepb.E_Field)
}

func hasValidateOptionsInMessage(msg *protogen.Message) bool {
	return proto.HasExtension(msg.Desc.Options(), validatepb.E_Message)
}

func buildHTTPRule(g *protogen.GeneratedFile, service *protogen.Service, m *protogen.Method, rule *annotations.HttpRule, conf *GenConfig) (*template.MethodDesc, error) {
	res := parser.ParseHttpRule(rule)
	if res.Path == "" {
		res.Path = fmt.Sprintf("%s/%s/%s", conf.omitemptyPrefix, service.Desc.FullName(), m.Desc.Name())
	}
	md, err := buildMethodDesc(g, m, res, conf)
	if err != nil {
		return nil, err
	}
	if _, ok := parser.NoBodyMethods[res.Method]; ok {
		if rule.Body != "" {
			log.Warn("Method `%s.%s` body should not be declared. File: `%s`",
				m.Parent.Desc.Name(),
				m.Desc.Name(),
				m.Parent.Location.SourceFile,
			)
		}
	} else {
		if rule.Body == "" {
			log.Warn("Method `%s.%s` body is not declared. File: `%s`",
				m.Parent.Desc.Name(),
				m.Desc.Name(),
				m.Parent.Location.SourceFile,
			)
		}
	}
	return md, nil
}

func buildMethodDesc(g *protogen.GeneratedFile, m *protogen.Method, rule *parser.HttpRule, conf *GenConfig) (*template.MethodDesc, error) {
	route, err := parser.GinRoute(rule.Path)
	if err != nil {
		log.Error("Method `%s.%s` route `%s` parse error: %v. File: `%s`",
			m.Parent.Desc.Name(),
			m.Desc.Name(),
			rule.Path,
			err,
			m.Parent.Location.SourceFile,
		)
		return nil, err
	}
	defer func() { methodSets[m.GoName]++ }()
	vars := parser.GinURIParams(m, route)
	forms := parser.GinQueryForm(m, rule.Method, vars)
	comment := parser.MethodCommend(m)
	swag := &parser.SwagParams{
		Method:        rule.Method,
		Path:          parser.ConvertGinToSwaggerPath(route),
		Auth:          conf.swaggerAuth,
		PathVars:      vars,
		QueryVars:     forms,
		DataResponse:  conf.packageDesc.DataResponseType,
		ErrorResponse: conf.packageDesc.ErrorResponseType,
	}
	needValidate := hasValidateOptionsInMessage(m.Input) || slices.ContainsFunc(m.Input.Fields, hasValidateOptions)
	return &template.MethodDesc{
		Name:         m.GoName,
		OriginalName: string(m.Desc.Name()),
		Num:          methodSets[m.GoName],
		Request:      g.QualifiedGoIdent(m.Input.GoIdent),
		Reply:        g.QualifiedGoIdent(m.Output.GoIdent),
		Comment:      comment,
		Path:         rule.Path,
		Method:       rule.Method,
		HasVars:      len(vars) > 0,
		HasQuery:     len(forms) > 0,
		HasBody:      rule.HasBody,
		Body:         rule.Body,
		ResponseBody: rule.ResponseBody,
		Swagger:      parser.BuildAnnotations(m, swag),
		GinPath:      route,
		NeedValidate: needValidate,
	}, nil
}
