package gen

import (
	"fmt"
	"io"
	"text/template"
)

type Field struct {
	Name string
	Type string
}

type Desc struct {
	Num    int
	Fields []Field
}

const tupleTemplate = `// Package tuple Code generated by go generate; DO NOT EDIT.
package tuple

import (
    "encoding/json"
    "fmt"
)

{{range .}}
// Of{{.Num}} represents a tuple of {{.Num}} elements
type Of{{.Num}}[{{range $i, $f := .Fields}}{{if $i}}, {{end}}{{.Type}} any{{end}}] struct {
    {{range .Fields}}{{.Name}} {{.Type}}
    {{end}}
}

// New{{.Num}} creates a new tuple of {{.Num}} elements
func New{{.Num}}[{{range $i, $f := .Fields}}{{if $i}}, {{end}}{{.Type}} any{{end}}]({{range $i, $f := .Fields}}{{if $i}}, {{end}}{{lower .Name}} {{.Type}}{{end}}) Of{{.Num}}[{{range $i, $f := .Fields}}{{if $i}}, {{end}}{{.Type}}{{end}}] {
    return Of{{.Num}}[{{range $i, $f := .Fields}}{{if $i}}, {{end}}{{.Type}}{{end}}]{
        {{range .Fields}}{{.Name}}: {{lower .Name}},
        {{end}}
    }
}

// MarshalJSON implements json.Marshaler interface
func (t *Of{{.Num}}[{{range $i, $f := .Fields}}{{if $i}}, {{end}}{{.Type}}{{end}}]) MarshalJSON() ([]byte, error) {
    return json.Marshal([]interface{}{ {{range $i, $f := .Fields}}{{if $i}}, {{end}}t.{{.Name}}{{end}} })
}

// UnmarshalJSON implements json.Unmarshaler interface
func (t *Of{{.Num}}[{{range $i, $f := .Fields}}{{if $i}}, {{end}}{{.Type}}{{end}}]) UnmarshalJSON(data []byte) error {
    var raw []json.RawMessage
    if err := json.Unmarshal(data, &raw); err != nil {
        return fmt.Errorf("failed to unmarshal array: %w", err)
    }

    if len(raw) < {{.Num}} {
        return fmt.Errorf("expected array of length {{.Num}}, got %d", len(raw))
    }

    {{range $i, $f := .Fields}}
    if err := json.Unmarshal(raw[{{$i}}], &t.{{.Name}}); err != nil {
        return fmt.Errorf("failed to unmarshal {{lower .Name}} element: %w", err)
    }
    {{end}}

    return nil
}
{{end}}
`

func Gen(writer io.Writer) {
	fieldNames := []string{
		"First", "Second", "Third", "Fourth", "Fifth", "Sixth", "Seventh", "Eighth", "Ninth", "Tenth",
	}
	typesNames := []string{
		"A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
	}
	var list []Desc
	for i := 2; i <= 10; i++ {
		row := Desc{Num: i}
		for j := 0; j < i; j++ {
			row.Fields = append(row.Fields, Field{
				Name: fieldNames[j],
				Type: typesNames[j],
			})
		}
		list = append(list, row)
	}

	tmpl, err := template.New("tuple").Funcs(template.FuncMap{
		"lower": func(s string) string {
			return string(s[0]+32) + s[1:]
		},
	}).Parse(tupleTemplate)
	if err != nil {
		fmt.Println("Error parsing template:", err)
		return
	}

	err = tmpl.Execute(writer, list)
	if err != nil {
		fmt.Println("Error executing template:", err)
	}
}
